As mentioned in the <<jdbcQuickStart, Quick Start>> section, if you need to customize how entities map to the table and column names of the database you can use JPA annotations to do so or Predators own annotations in the `io.micronaut.data.annotation` package.

An important aspect of Predator JDBC is that regardless whether you use JPA annotations of Predator annotations the entity classes must be compiled with Predator.

This is because Predator pre-computes the persistence model (the relationships between entities, the class/property name to table/column name mappings) at compilation time, which is one of the reasons Predator JDBC can startup so fast.

An example of mapping with Predator annotations can be seen below:

.Predator Annotation Mapping Example
[source,java]
----
include::predator-tck/src/main/java/io/micronaut/data/tck/entities/Country.java[]
----

The following table summarizes the different annotations and what they enable. If you are familiar with and prefer the JPA annotations then feel free to skip to the next section:

.Predator Annotations
[cols=2*]
|===
|*Annotation*
|*Description*

|ann:data.annotation.AutoPopulated[]
|Meta annotation for a value that should be auto-populated by Predator (such as time stamps and UUIDs)

|ann:data.annotation.DateCreated[]
|Allows assigning a data created value (such as a `java.time.Instant`) prior to an insert

|ann:data.annotation.DateUpdated[]
|Allows assigning a last updated value (such as a `java.time.Instant`) prior to an insert

|ann:data.annotation.GeneratedValue[]
|Specifies that the property value is generated by the database and not included in inserts

|ann:data.annotation.Id[]
|Specifies the ID of an entity

|ann:data.annotation.MappedEntity[]
|Specifies the entity is mapped to the database

|ann:data.annotation.MappedProperty[]
|Used to customize the column name, definition and data type

|ann:data.annotation.Relation[]
|Used to specify a relationship (one-to-one, one-to-many etc.)

|ann:data.annotation.Transient[]
|Used to specify a property is transient

|===


=== Supported JPA Annotations

In the case of using JPA only a subset of annotations are supported including the following:

* `@Table`
* `@Id`
* `@Column`
* `@Transient`
* `@JoinTable`
* `@OneToMany`
* `@OneToOne`
* `@ManyToOne`
* `@ManyToMany`

Again Predator JDBC is not an ORM, but instead a simple data mapper so many of the concepts in JPA simply don't apply, however for users familiar with these annotations it is handy being able to use them.

=== ID Generation

The default ID generation expects the database to populate a value for the ID such as an `IDENTITY` column.

You can remove the `@GeneratedValue` annotation and in this case the expectation is that you will assign an ID before calling `save()`.

If you wish to uses sequences for the ID you should invoke the SQL that generates the sequence value and assign it prior to calling `save()`.

Automatically assigned UUIDs are also supported by adding a property annotated with `@Id` and `@AutoPopulated`.

=== Constructor Arguments

Predator JDBC also allows the definition of immutable objects using constructor arguments instead of getters/setters. If you define multiple constructors then the one used to create the object from the database should be annotated with `io.micronaut.core.annotation.Creator`.

For example:

snippet::example.Manufacturer[project-base="doc-examples/jdbc-example", source="main"]

As you can see from the example above, the `ID` of the object should however include a setter since this has to be assigned from the database generated value.

=== Naming Strategies

The default naming strategy when converting camel case class and property names to database tables and columns is to use underscore separated lower case. In other words `FooBar` becomes `foo_bar`.

If this is not satisfactory then you can customize this by setting the `namingStrategy` member of the ann:data.annotation.MappedEntity[] annotation on the entity:

.Predator Naming Strategy
[source,java]
----
include::predator-tck/src/main/java/io/micronaut/data/tck/entities/CountryRegion.java[tags="namingStrategy"]
    ...
}
----

Few important things to note. Since Predator pre-computes the table and column name mappings at compilation time the specified api:data.model.naming.NamingStrategy[] implementation must be on the annotation processor classpath (`annotationProcessor` scope for Java or `kapt` for Kotlin).

In addition if you don't want to repeat the above annotation definition on every entity it is handy to define a meta-annotation where the above annotation definition is applied to another annotation that you add to your class.

=== Association Fetching

Predator is a simple data mapper, hence it will not fetch any associations for you using techniques like lazy loading of entity proxies for single-ended associations.

You must instead specify ahead of time what data you want to fetch. You cannot map an association as being eager or lazy. The reason for this design choice is simple, even in the JPA world accessing lazy associations or lazy initialization collections is considered bad practise due to the N+1 query issue and the recommendation is always to write an optimized join query.

Predator JDBC takes this a step further by simply not supporting those features considered bad practise anyway. However, it does impact how you may model an association. For example if you define an association in a constructor argument such as the following entity:

snippet::example.Product[project-base="doc-examples/jdbc-example", source="main"]

Then attempt to read the `Product` entity back without specifying a join an exception will occur since the `manufacturer` association is not `Nullable`.

There are few ways around this, one way is to declare at the repository level to always fetch `manufacturer`, another is declare the `@Nullable` annotation on the `manufacturer` argument to allow it to be declared `null` (or in Kotlin add `?` to the end of the constructor argument name). Which approach you choose is dependent on the design of the application.

The following section provides more coverage on handling joins.