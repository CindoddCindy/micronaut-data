As seen in the <<quickStart, Quick Start>> repositories in Predator are defined as interfaces that are annotated with the ann:data.annotation.Repository[] annotation.

The ann:data.annotation.Repository[] annotation accepts an optional string value which represents the name of the connection or datasource in a multiple datasource scenario. By default Predator will look for the default datasource.

The entity to treat as the root entity for the purposes of querying is established either from the method signature or from the generic type parameter specified to the api:data.repository.GenericRepository[] interface.

If no root entity can be established then a compilation error will occur.

The following table summarizes the repository interfaces that come with Predator:

.Builtin Repository Interfaces
[cols=2*]
|===
|*Interface*
|*Description*

|api:data.repository.GenericRepository[]
|A root interface that features no methods but defines the entity type and ID type as generic arguments

|api:data.repository.CrudRepository[]
|Extends api:data.repository.GenericRepository[] and adds methods to perform CRUD

|api:data.repository.PageableRepository[]
|Extends api:data.repository.CrudRepository[] and adds methods for pagination
|===

Note that in addition to interfaces you can also define repositories as abstract classes:

snippet::example.AbstractBookRepository[project-base="doc-examples/example", source="main"]

As you can see from the above example, using abstract classes can be useful as it allows you to combine custom code that interacts with JPA and repository interface code implemented automatically by Predator.