Micronaut Predator (short for **Pre**computed **Dat**a **R**epositories) is a database access tookit that uses Ahead of Time (AoT) compilation to pre-compute queries for repository interfaces that are then executed by a thin, lightweight runtime layer.

Predator is inspired by https://gorm.grails.org[GORM] and https://spring.io/projects/spring-data[Spring Data], however improves on those solutions in the following ways:

* *No runtime model* - Both GORM and Spring Data maintain a runtime meta-model that uses reflection to model relationships between entities. This model consumes significant memory and memory requirements grow as your application size grows.
* *No query translation* - Both GORM and Spring Data use regular expressions and pattern matching in combination with runtime generated proxies to translate a method definition on a Java interface into a query. No such translation exists in Predator and this work is carried out by the Micronaut compiler.
* *No Reflection or Runtime Proxies* - Predator uses no reflection or runtime proxies, resulting in better performance, smaller stack traces and reduced memory consumption (Note that the backing implementation, for example Hibernate, may use reflection).
* *Type Safety* - Predator will actively check at compile time that a repository method can be implemented and fail compilation if it cannot.

Predator provides a general API for translating a compile time Query model into a query at compilation time and provides runtime support for the following backends:

* JPA (Hibernate)
* SQL (JDBC)

Further implementations for other databases is planned in the future.

The following sections will take you through the basics of querying and using Predator, if you wish to understand more detail about how Predator works check out the <<howItWorks, How Predator Works>> section.